# **Real, User and Sys process time statistics**

[Origin](https://stackoverflow.com/questions/556405/what-do-real-user-and-sys-mean-in-the-output-of-time1)

**真实的、用户和系统的进程时间统计**

其中一件事与其他不同。Real指的是实际经过的时间；User和Sys指的是进程仅使用的CPU时间。

- 真实时间是指从通话开始到结束的时间。这包括了其他进程使用的时间片以及进程被阻塞的时间（例如等待I/O完成的时间）。
- 用户是进程中在用户模式代码（内核外）中花费的CPU时间。这仅是执行进程时实际使用的CPU时间。其他进程和进程阻塞的时间不计入此数。
- Sys是进程内在内核中花费的CPU时间量。这意味着在内核中执行的系统调用所花费的CPU时间，而不是仍在用户空间运行的库代码。与'user'一样，这只是进程使用的CPU时间。请参阅下面对内核模式（也称为'supervisor'模式）和系统调用机制的简要描述。

`User+Sys` 会告诉你进程实际使用的CPU时间。请注意，这是跨所有CPU的时间，所以如果进程有多个线程（并且该进程在具有多个处理器的计算机上运行），它可能会超过 `Real` 报告的墙钟时间（通常发生）。请注意，在输出中，这些数字还包括所有子进程（及其后代）的 `User` 和 `Sys` 时间，以及它们可能已经被 `wait(2)` 或 `waitpid(2)` 收集到的时间，尽管底层系统调用分别返回进程及其子进程的统计信息。

在多处理器的机器上，多线程的进程或分叉子进程的进程的经过时间可能小于总CPU时间 - 因为不同的线程或进程可以并行运行。此外，报告的时间统计来自不同的来源，因此对于非常短时间运行的任务记录的时间可能会受到舍入误差的影响，正如原帖中所示的例子。

**A brief primer on Kernel vs. User mode
内核模式与用户模式简介**

在Unix或任何受保护内存的操作系统中，“内核”或“监管者”模式指的是CPU可以运行的特权模式。只有在CPU处于此模式下，才能执行某些可能影响安全性或稳定性的特权操作；这些操作对应用程序代码不可用。一个例子是通过操作内存管理单元（MMU）来访问另一个进程的地址空间。通常情况下，用户模式代码无法做到这一点（有充分的理由），尽管它可以通过内核请求共享内存，多个进程可以读取或写入该内存。在这种情况下，共享内存是通过安全机制明确地从内核请求的，并且两个进程必须明确地附加到它才能使用它。

特权模式通常被称为“内核”模式，因为内核是由在此模式下运行的CPU执行的。为了切换到内核模式，您必须发出一个特定的指令（通常称为陷阱），该指令将CPU切换到内核模式并从跳转表中的特定位置运行代码。出于安全原因，您不能切换到内核模式并执行任意代码 - 陷阱通过一个地址表进行管理，除非CPU正在运行在监管者模式下，否则无法写入这些地址。您使用一个明确的陷阱号进行陷阱，并在跳转表中查找地址；内核具有有限数量的受控入口点。

**More about 'sys' 更多关于'sys'的信息**

有些事情你的代码无法在用户模式下完成，比如分配内存或访问硬件（硬盘、网络等）。这些都在内核的监督下进行，只有内核才能完成。一些操作，比如 `malloc` 或 `fread` / `fwrite` ，会调用这些内核函数，这将被计算为“sys”时间。不幸的是，情况并不像“每次调用malloc都会计入‘sys’时间”那么简单。调用 `malloc` 会进行一些自己的处理（仍然计入“user”时间），然后在某个地方可能调用内核函数（计入“sys”时间）。从内核调用返回后，还会有一些时间在“user”模式下，然后 `malloc` 将返回到你的代码。至于何时发生切换，以及有多少时间在内核模式下...你无法说。这取决于库的实现。此外，其他看似无害的函数也可能在后台使用 `malloc` 等函数，这将再次计入“sys”时间。

## Profilers

### CPU
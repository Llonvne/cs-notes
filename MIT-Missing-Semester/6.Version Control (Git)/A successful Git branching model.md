# A successful Git branching model

[Origin](https://nvie.com/posts/a-successful-git-branching-model/)

# At 2010年1月5日星期二

## Note of reflection (March 5, 2020) 反思记录（2020年3月5日）

>  在这10年里，git-flow（本文中介绍的分支模型）在许多软件团队中变得非常流行，以至于人们开始将其视为某种标准，但不幸的是，也将其视为教条或万能药。
>
> 在这10年里，Git本身已经席卷全球，使用Git开发的最流行的软件类型正在更多地转向Web应用程序-至少在我的过滤泡泡中是这样。Web应用程序通常是持续交付的，不会回滚，并且您不必支持在野外运行的多个软件版本。
>
> 这不是我在10年前写博客时所想的软件类别。如果你的团队正在进行软件的持续交付，我建议采用更简单的工作流程（比如GitHub流程），而不是试图将git-flow强行适应你的团队。
>
> 然而，如果您正在构建明确版本化的软件，或者需要支持多个版本的软件在使用中，那么git-flow可能仍然适合您的团队，就像过去10年里适合其他人一样。在这种情况下，请继续阅读。
>
> 总之，永远记住没有万能药。考虑你自己的背景。不要恨。自己决定。

在这篇文章中，我介绍了我在大约一年前为一些项目（包括工作和私人项目）引入的开发模型，这个模型被证明非常成功。我一直想写一些关于它的内容，但一直没有找到时间来做这件事，直到现在。我不会谈论任何项目的细节，只会谈论分支策略和发布管理。

<img src="./assets/git-model@2x.png" alt="img" style="zoom:50%;" />

作为开发者，我更喜欢Git，它真正改变了开发者对合并和分支的思考方式。从我来自的经典CVS/Subversion世界来看，合并/分支一直被认为有点可怕（“小心合并冲突，它们会咬你！”），而且只是偶尔才会进行。

## Decentralized but centralized [¶](https://nvie.com/posts/a-successful-git-branching-model/#decentralized-but-centralized) 分散但集中

<img src="./assets/centr-decentr@2x.png" alt="img" style="zoom:50%;" />

## The main branches [¶](https://nvie.com/posts/a-successful-git-branching-model/#the-main-branches) 主要分支

<img src="./assets/main-branches@2x.png" alt="img" style="zoom:50%;" />

在核心部分，开发模型受到现有模型的极大启发。中央仓库包含两个主要分支，具有无限的生命周期：

- `master`
- `develop`

在 `master` 分支上，每个Git用户都应该很熟悉。与 `master` 分支平行存在另一个分支，称为 `develop` 。

我们认为 `origin/master` 是主分支，其中 `HEAD` 的源代码始终反映出一个可用于生产的状态。

我们认为 `origin/develop` 是主分支，其中 `HEAD` 的源代码始终反映了下一个发布版本的最新交付的开发更改状态。有些人称之为“集成分支”。这是任何自动夜间构建的构建来源。

当 `develop` 分支中的源代码达到稳定点并准备好发布时，所有的更改应该以某种方式合并回 `master` ，然后标记一个发布版本号。具体如何完成将在后续讨论中进一步说明。

因此，每次将更改合并回 `master` 时，根据定义，这是一个新的生产发布。我们倾向于非常严格地执行此操作，因此理论上，我们可以使用Git钩子脚本，在 `master`上提交时自动构建和部署我们的软件到生产服务器。

## Supporting branches 支持分支

除了主要分支 `master` 和 `develop` 之外，我们的开发模型还使用了各种支持分支来帮助团队成员进行并行开发，方便跟踪功能，为生产发布做准备，并在快速修复实时生产问题时提供帮助。与主要分支不同，这些分支总是有限的生命周期，因为它们最终会被删除。

我们可能使用的不同类型的分支有：

- Feature branches 特性分支
- Release branches 发布分支
- Hotfix branches 热修分支

每个分支都有特定的目的，并受到严格的规则约束，规定了哪些分支可以作为它们的起始分支，哪些分支必须作为它们的合并目标。我们将在一分钟内逐个介绍它们。

这些分支从技术角度来看并不“特殊”。分支类型是根据我们的使用方式进行分类的。它们当然是普通的 Git 分支。

### eature branches 特性分支

<img src="./assets/fb@2x.png" alt="img" style="zoom:50%;" />

- May branch off from: 可能分支出自：

  `develop`

- Must merge back into: 必须合并回到：

  `develop`

- Branch naming convention: 分支命名规范

  除了 `master` 、 `develop` 、 `release-*` 或 `hotfix-*` 之外的任何东西

特性分支（有时也称为主题分支）用于开发即将发布的或遥远未来的新功能。在开始开发一个功能时，该功能将被合并到哪个发布版本中可能在那时还不确定。特性分支的本质是它存在于功能开发期间，但最终将被合并回 `develop` （以确保将新功能添加到即将发布的版本中）或被丢弃（在实验失败的情况下）。

特性分支通常只存在于开发者的代码库中，而不在 `origin` 中。

#### Creating a feature branch  创建一个功能分支

开始开发新功能时，从 `develop` 分支分离出来。

```
$ git checkout -b myfeature develop
```

#### 在开发中加入一个已完成的功能

已完成的功能可以合并到 `develop` 分支中，以确保将它们添加到即将发布的版本中

`--no-ff` 标志会导致合并始终创建一个新的提交对象，即使可以通过快进方式进行合并。这样可以避免丢失有关功能分支历史存在的信息，并将一起添加功能的所有提交组合在一起。比较：

<img src="./assets/merge-without-ff@2x.png" alt="img" style="zoom:50%;" />

在后一种情况下，无法从Git历史中看出哪些提交对象一起实现了一个功能 - 您必须手动阅读所有日志消息。在后一种情况下，撤销整个功能（即一组提交）是一件真正头疼的事情，而如果使用了 `--no-ff` 标志，则可以轻松完成。

### Release branches 发布分支 ¶

May branch off from:
可能分支出自：

```
develop
```

Must merge back into:
必须合并回到：

`develop` and `master` 和

Branch naming convention:
分支命名规范

```
release-*
```

发布分支支持准备新的生产发布。它们允许在最后一刻进行细微的修正。此外，它们还允许进行小的错误修复和准备发布的元数据（版本号、构建日期等）。通过在发布分支上完成所有这些工作，主分支就可以接收下一个重大发布的功能。

从 `develop` 分支出一个新的发布分支的关键时刻是当develop（几乎）反映了新发布的期望状态时。至少在此时，所有计划构建的发布中的功能必须合并到 `develop`中。所有计划用于未来发布的功能则不可以，它们必须等到发布分支分支出来后再合并。

正是在发布分支的开始阶段，即将发布的版本才被分配一个版本号，而不是在此之前。在那一刻之前，该分支反映了“下一个发布”的更改，但不清楚该“下一个发布”最终会成为0.3还是1.0，直到发布分支开始。这个决定是在发布分支开始时根据项目的版本号增加规则来执行的。

#### 创建一个发布分支

发布分支是从 `develop` 分支创建的。例如，假设版本1.1.5是当前的生产发布版本，我们即将进行一次重大发布。状态 `develop` 已准备好进行“下一个发布”，我们决定将其成为版本1.2（而不是1.1.6或2.0）。因此，我们创建一个分支，并给发布分支命名以反映新的版本号：

创建一个新的分支并切换到该分支后，我们会增加版本号。在这里， `bump-version.sh` 是一个虚构的shell脚本，它会修改工作副本中的一些文件以反映新的版本号。（当然，这也可以是手动修改，重点是一些文件会发生变化。）然后，增加的版本号被提交。

这个新分支可能会存在一段时间，直到最终发布。在此期间，可能会在这个分支上应用错误修复（而不是在 `develop` 分支上）。严禁在此处添加大型新功能。它们必须合并到 `develop` 中，因此需要等待下一个大版本发布。

#### Finishing a release branch

当发布分支的状态准备好成为真正的发布时，需要执行一些操作。首先，将发布分支合并到 `master` （因为根据定义， `master` 上的每个提交都是一个新的发布）。接下来，必须为 `master` 上的该提交打上标签，以便将来可以轻松参考这个历史版本。最后，需要将发布分支上的更改合并回 `develop` ，以便将来的发布版本也包含这些错误修复。

为了保留在发布分支中所做的更改，我们需要将其合并回 `develop` 中。在Git中：

这一步骤很可能会导致合并冲突（尤其是因为我们已经更改了版本号）。如果出现冲突，请修复并提交。

现在我们真的完成了，可以删除发布分支，因为我们不再需要它了

### Hotfix branches [¶](https://nvie.com/posts/a-successful-git-branching-model/#hotfix-branches) 热修复分支

May branch off from:
可能分支出自：

```
master
```

Must merge back into:
必须合并回到：

`develop` and `master` 和

Branch naming convention:
分支命名规范

```
hotfix-*
```

热修补分支与发布分支非常相似，它们都是为了准备新的生产发布，尽管是非计划的。它们源于必须立即处理生产版本中不希望出现的状态的需求。当必须立即解决生产版本中的关键错误时，可以从标记生产版本的主分支上分支出一个热修补分支。

本质是团队成员（在 `develop` 分支上）的工作可以继续，同时另一个人正在准备快速的生产修复。

#### Creating the hotfix branch [¶](https://nvie.com/posts/a-successful-git-branching-model/#creating-the-hotfix-branch) 创建热修复分支

热修复分支是从 `master` 分支创建的。例如，假设版本1.2是当前正在运行的生产发布版本，并由于严重错误而引起问题。但是 `develop` 上的更改尚不稳定。然后，我们可以创建一个热修复分支并开始修复问题：

分支后不要忘记提升版本号！

然后，修复错误并将修复提交为一个或多个单独的提交。

完成后，错误修复需要合并回 `master` ，同时也需要合并回 `develop` ，以确保错误修复也包含在下一个发布版本中。这与完成发布分支的方式完全相似。

这里的一个例外是，当存在一个发布分支时，热修复的更改需要合并到该发布分支中，而不是 `develop` 。将错误修复合并到发布分支中最终会导致错误修复也合并到 `develop` 中，当发布分支完成时。（如果 `develop` 中的工作立即需要此错误修复，并且不能等待发布分支完成，您也可以安全地将错误修复合并到 `develop`中。）

## Summary [¶](https://nvie.com/posts/a-successful-git-branching-model/#summary) 摘要

虽然这个分支模型没有什么真正令人震惊的新内容，但这篇文章开始的“大局观”图表在我们的项目中非常有用。它形成了一个优雅的心智模型，易于理解，并允许团队成员对分支和发布流程形成共同的理解。
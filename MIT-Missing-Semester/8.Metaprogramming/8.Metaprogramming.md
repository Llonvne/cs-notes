# Metaprogramming

 ## BuildSystem

### Make

`make` 是最常见的构建系统之一，在几乎任何基于UNIX的计算机上都可以找到它的安装。它有一些缺点，但对于简单到中等规模的项目来说，它运行得相当不错。当你运行 `make` 时，它会查找当前目录中的一个名为 `Makefile` 的文件。所有的目标、它们的依赖关系和规则都在那个文件中定义。让我们来看一个例子：

该文件中的每个指令都是使用右侧生成左侧的规则。或者换句话说，右侧命名的内容是依赖项，而左侧是目标。缩进的块是一系列程序，用于从这些依赖项生成目标。在 `make` 中，第一个指令还定义了默认目标。如果您不带任何参数运行 `make` ，它将构建此目标。或者，您可以运行类似 `make plot-data.png` 的命令，它将构建该目标。

在规则中的 `%` 是一个“模式”，它将在左侧和右侧匹配相同的字符串。例如，如果请求目标 `plot-foo.png` ， `make` 将寻找依赖项 `foo.dat` 和 `plot.py` 。现在让我们看看如果我们在一个空的源目录中运行 `make` 会发生什么。

## Version

### 语义化版本 2.0.0

https://semver.org/lang/zh-CN/

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

1. 主版本号：当你做了不兼容的 API 修改，
2. 次版本号：当你做了向下兼容的功能性新增，
3. 修订号：当你做了向下兼容的问题修正。

先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

### LockFile

在使用依赖管理系统时，您可能会遇到锁定文件的概念。锁定文件只是一个列出每个依赖项当前所依赖的确切版本的文件。通常，您需要显式运行更新程序以升级到依赖项的新版本。这样做有很多原因，比如避免不必要的重新编译、实现可重复构建，或者不自动更新到最新版本（可能存在问题）。这种依赖项锁定的极端形式是供应商化，即将所有依赖项的代码复制到自己的项目中。这样可以完全控制对其的任何更改，并允许您引入自己的更改，但也意味着您必须随时间显式地从上游维护者那里获取任何更新。

# Continuous integration systems

持续集成，简称CI，是一个“每当代码发生变化时运行的东西”的总称，有许多公司提供各种类型的CI，通常对于开源项目是免费的。其中一些大公司包括Travis CI、Azure Pipelines和GitHub Actions。它们的工作方式大致相同：您向存储库添加一个文件，描述了在存储库发生各种事件时应该发生什么。迄今为止，最常见的规则是“当有人推送代码时，运行测试套件”。当事件触发时，CI提供商会启动一个虚拟机（或多个），运行您的“配方”中的命令，然后通常在某个地方记录结果。您可以设置通知，以便在测试套件停止通过时收到通知，或者在测试通过时在存储库上显示一个小徽章.

## A brief aside on testing
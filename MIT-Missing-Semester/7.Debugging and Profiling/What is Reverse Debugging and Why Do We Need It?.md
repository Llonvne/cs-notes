# **What is Reverse Debugging and Why Do We Need It?**

https://undo.io/resources/reverse-debugging-whitepaper/

这篇技术论文旨在解释传统的调试方法如何难以应对当今软件的规模和复杂性。它权衡了当前市场上调试工具的潜在优点和缺点，并阐述了逆向调试技术（又称时间旅行调试）、它是什么以及为什么认真的程序员应该关心。

## Challenges of debugging 调试的挑战

调试的难度是最初编写代码的两倍。因此，如果您尽可能巧妙地编写代码，那么根据定义，您就不够聪明，无法调试它。

## Traditional debugging tools and techniques 传统的调试工具和技术

### Programmatic techniques 程序化技术

本质上，开发人员以帮助他们发现错误的方式修改或编写他们的程序。技术包括打印语句、断言和测试套件的使用。

### Special case diagnosis/analysis tools 特殊情况诊断/分析工具

这些自动化工具（例如 Coverity、Purify 和 Valgrind）可检测最常见的错误（例如内存访问违规、触及未分配的内存或潜在的死锁情况）。虽然它们有助于解决特定类型的错误，但它们并不全面，无法全面覆盖。如果您的错误不完全属于这些类别之一，则此类工具不会提供任何帮助。即使是非常常见的错误实例也可以逃避这些工具。最近的 Heartbleed bug 是一种非常常见的 bug（缓冲区过度读取）形式，但所有常用的检测工具都未能发现它。

### General purpose debuggers 通用调试器

当特殊情况诊断工具无法发现错误时，许多程序员会转向通用调试器，例如 GDB。这些让程序员一步一步地前进，通过他们的代码并设置观察点。

然而，调试涉及到逆向思维，正如 Brian Kernighan 和 Rob Pike 在他们的《编程实践》一书中指出的那样：

> 从崩溃程序的状态进行推理，以确定可能导致此问题的原因。调试涉及反向推理，例如解决谋杀之谜。不可能的事情发生了，唯一可靠的信息是它确实发生了。所以我们必须从结果中倒着想，找出原因。

因此，要真正发挥作用，调试器需要帮助程序员向后遍历程序的执行过程。因此，开发人员需要一种不同的方法，这就是可逆调试的用武之地。

## Introducing reverse debugging (a.k.a. time travel debugging) 引入反向调试（又名时间旅行调试）

时间旅行调试器使开发人员能够记录所有程序活动（每次内存访问、每次计算以及每次对操作系统的调用），然后倒带和重播以检查程序状态。如此巨大的数据量是通过一个强有力的比喻来呈现的：及时向后（并再次向前）检查程序状态的能力。从本质上讲，它们使开发人员能够通过让他们倒回代码以在程序中向后和向前行走来解决谋杀之谜。以追踪某些损坏的内存为例。使用时间旅行调试器，开发人员可以简单地在包含错误数据的变量上放置一个观察点，然后向后运行以直接转到最近修改它的代码行。需要很长时间才能发现的错误可以在几分钟内找到。

### General development productivity 一般开发生产力

将时间旅行调试作为开发和调试过程的一部分可以提高整体开发效率。可以更快地发现常见但难以识别的错误，从而节省开发人员的时间。时间旅行调试器与开源调试器GDB完全兼容，可以轻松集成到开发环境中，无需进行大量培训。时间旅行调试还可以帮助开发人员熟悉遗留代码或不是他们自己编写但现在必须使用的代码。

### Finding and fixing intermittent bugs 查找并修复间歇性错误

零星的错误看似随机出现，但却非常难以发现，而且可能对公司声誉造成最大的损害。它们可以轻松地溜过正常调试例程的网，并且只有在代码接近交付时（或更糟糕的是，已经交付时）才会浮出水面。通过运行时间旅行调试器直到间歇性错误出现，开发人员可以从故障点逐行向后退一步，直到找到错误本身。如有必要，可以在不同的服务器上运行调试器的多个实例，以增加错误出现的机会。

### Bugs in production software that manifest at a customer site 生产软件中出现在客户站点的错误

对于许多软件供应商来说，他们的工具正在客户站点上使用。如果程序崩溃，供应商必须了解情况，以便在调查之前在内部重现问题。不幸的是，这通常是不可能的，这意味着软件供应商别无选择，只能派工程师到客户现场调查故障。在演示问题的机器上现场运行时间旅行调试器意味着，下次发生问题时，工程师可以退后一步查看出了什么问题。

### Long run times 运行时间长

有时，跟踪错误本身可能是 O(n2) 迭代：运行调试器 5 分钟直到错误出现，在代码中较早设置断点并再次运行 4 分钟，设置较早的断点并重新运行，等等。反向调试，耗时的运行-重启周期可以减少到 O(n) 过程。运行直到遇到错误，然后退一步查看导致问题的原因。你错过了吗？向前迈出一点，然后再向后退一点。

### Frequently-called functions 经常调用的函数

以一个函数为例，该函数被调用多次，但在大约一千次调用后失败，并出现 SIGSEGV 或 SIGFPE 等错误。在函数中设置断点效果不佳，因为它会在第一次出现时停止，而您确实希望它在最后一次出现时停止 - 但这涉及预测未来！使用时间旅行调试器，可以运行到最后然后设置断点。反向运行时，您遇到的第一个断点是上次执行代码的时间。

### Dynamic code 动态代码

一些应用程序在运行时生成专门的代码。调试这样的代码很困难，因为源代码分析工具显然无法提供帮助；没有任何正常的调试信息来定位函数，并且代码可以在不同的运行中在不同的地址生成。时间旅行调试器允许开发人员详细检查单次运行，而不会遇到与重新运行相关的麻烦。

### Intermittent bug 间歇性错误

间歇性错误可能只会在 300 次运行中出现 1 次。如果调查 bug 的开发人员发现需要设置不同的断点或添加另一个日志命令来帮助理解问题，那么在再次遇到 bug 之前将需要大量的运行，因此进度会非常缓慢。时间旅行调试器无法帮助使错误更快出现，但一旦出现，就可以检查整个运行历史记录。

### Dynamically generated code, stack corruption 动态生成的代码，堆栈损坏

通常一个问题是，错误会创建破坏堆栈的代码。 GDB 无法应对，并且 coredump 没有提供任何信息。使用时间旅行调试，开发人员可以倒回以查看堆栈损坏并在几分钟内解决问题。

### Memory leaks 内存泄漏

不明显的内存泄漏可能会导致软件随着时间的推移运行速度变慢，甚至可能崩溃。使用传统工具很难调试内存泄漏，因为缓冲区的分配和应释放的时间点之间存在很大的时间差距。目前还不清楚问题出在哪里——问题很可能是在应该存在的地方缺少代码。更糟糕的是，如果程序重新运行，可能会泄漏不同的缓冲区。

时间旅行调试器使开发人员有机会处理单个示例故障，在历史记录中自由地前后移动，以确定丢失的代码应该在哪里。

### Real-time, network protocols 实时网络协议

当软件接收到意外格式的数据时，软件可能会失败。但是，如果调试器正在与具有实时限制的外部程序或设备进行通信，则可能无法使用调试器单步调试代码——其他设备可能会放弃。使用时间旅行调试器，无需在初始“记录”阶段停止，因为以后总是可以倒回。

### Race conditions 竞争条件

发生一个错误，其中一些代码访问了共享数据，但却声明了错误的锁。这会导致一个线程错误，其中两个线程都在访问数据A，但其中一个错误地锁定了数据B；因此，线程之间存在竞争条件。使用传统的调试器，错误将显示为数据A的损坏，但原因并不明显。通常的反应是再次运行并设置监视点，但这可能会导致很多误报，除非定义了一个复杂的条件来过滤出正确的访问，并且在设置了所有这些之后，很有可能下次bug不会出现。时间旅行调试使其更快：通过从检测到损坏的地方开始，设置一个监视点并向后运行，可以更快地找到损坏的源头。

### Race conditions 竞争条件

Corruption of a linked list leads to a crash, but it is difficult to see when the corruption occurs. Rather than having to continually re-run the program, reverse debugging allows developers to go back in time before the list was corrupted and use a binary search to quickly find out when the list got corrupted. This brings debugging time down from over an hour to less than 10 minutes.
链表的损坏会导致程序崩溃，但很难确定损坏发生的时间。与其不断重新运行程序，逆向调试允许开发人员回到链表损坏之前的时间，并使用二分搜索快速找出链表何时被损坏。这将调试时间从一个多小时缩短到不到10分钟。

## Introducing UDB 引入UDB

UDB是一个在Linux上针对C/C++的交互式时间旅行调试器，适用于任何用户模式编译的x86代码。这个逆向调试工具可以作为独立工具使用，也可以与Undo的LiveRecorder平台捆绑使用。它通过允许开发人员向前或向后步进或运行程序，消除了调试中的猜测。它具备现代调试器所期望的全部功能（如脚本编写、条件断点和监视点、全面检查全局和局部变量），并且还允许在程序运行反向时使用这些功能。Bug可以在几分钟内修复，而不是几周。


## 指定Makefile

我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的`-f` 或是 `--file` 参数（ `--makefile` 参数也行）。例如，我们有个makefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：

```
make –f hchen.mk
```

如果在make的命令行是，你不只一次地使用了 `-f` 参数，那么，所有指定的makefile将会被连在一起传递给make执行。

## 检查规则[¶](https://seisman.github.io/how-to-write-makefile/invoke.html#id3)

有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：

- `-n`, `--just-print`, `--dry-run`, `--recon`

  不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。

- `-t`, `--touch`

  这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。

- `-q`, `--question`

  这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。

- `-W <file>`, `--what-if=<file>`, `--assume-new=<file>`, `--new-file=<file>`

  这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件所发生的规则命令。

另外一个很有意思的用法是结合 `-p` 和 `-v` 来输出makefile被执行时的信息（这个将在后面讲述）。

隐含规则”也就是一种惯例，make会按照这种“惯例”心照不宣地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把 `.c` 文件编译成 `.o` 文件这一规则，你根本就不用写出来，make会自动推导出这种规则，并生成我们需要的 `.o` 文件。

## 使用隐含规则

```
foo : foo.o bar.o
    cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
```

我们可以注意到，这个Makefile中并没有写下如何生成 `foo.o` 和 `bar.o` 这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成命令。

make会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 `.o` 的目标的依赖文件置成 `.c` ，并使用C的编译命令 `cc –c $(CFLAGS) foo.c` 来生成 `foo.o` 的目标。也就是说，我们完全没有必要写下下面的两条规则：

```
foo.o : foo.c
    cc –c foo.c $(CFLAGS)
bar.o : bar.c
    cc –c bar.c $(CFLAGS)
```

因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器 `cc` 生成 `.o` 文件的规则，这就是隐含规则。

当然，如果我们为 `.o` 文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。

## 隐含规则一览

如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数 `-r` 或 `--no-builtin-rules` 选项来取消所有的预设置的隐含规则。

1. 编译C程序的隐含规则。

   `<n>.o` 的目标的依赖目标会自动推导为 `<n>.c` ，并且其生成命令是 `$(CC) –c $(CPPFLAGS)$(CFLAGS)`

2. 编译C++程序的隐含规则。

   `<n>.o` 的目标的依赖目标会自动推导为 `<n>.cc` 或 `<n>.cpp` 或是 `<n>.C` ，并且其生成命令是`$(CXX) –c $(CPPFLAGS) $(CXXFLAGS)` 。（建议使用 `.cc` 或 `.cpp` 作为C++源文件的后缀，而不是 `.C` ）

3. 编译Pascal程序的隐含规则。

   `<n>.o` 的目标的依赖目标会自动推导为 `<n>.p` ，并且其生成命令是 `$(PC) –c $(PFLAGS)` 。

4. 编译Fortran/Ratfor程序的隐含规则。

   `<n>.o` 的目标的依赖目标会自动推导为 `<n>.r` 或 `<n>.F` 或 `<n>.f` ，并且其生成命令是:

   - `.f` `$(FC) –c $(FFLAGS)`
   - `.F` `$(FC) –c $(FFLAGS) $(CPPFLAGS)`
   - `.r` `$(FC) –c $(FFLAGS) $(RFLAGS)`

5. 预处理Fortran/Ratfor程序的隐含规则。

   `<n>.f` 的目标的依赖目标会自动推导为 `<n>.r` 或 `<n>.F` 。这个规则只是转换Ratfor 或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：

   - `.F` `$(FC) –F $(CPPFLAGS) $(FFLAGS)`
   - `.r` `$(FC) –F $(FFLAGS) $(RFLAGS)`

6. 编译Modula-2程序的隐含规则。

   `<n>.sym` 的目标的依赖目标会自动推导为 `<n>.def` ，并且其生成命令是： `$(M2C) $(M2FLAGS)$(DEFFLAGS)` 。 `<n>.o` 的目标的依赖目标会自动推导为 `<n>.mod` ，并且其生成命令是： `$(M2C)$(M2FLAGS) $(MODFLAGS)` 。

7. 汇编和汇编预处理的隐含规则。

   `<n>.o` 的目标的依赖目标会自动推导为 `<n>.s` ，默认使用编译器 `as` ，并且其生成命令是： `$ (AS) $(ASFLAGS)` 。 `<n>.s` 的目标的依赖目标会自动推导为 `<n>.S` ，默认使用C预编译器 `cpp` ，并且其生成命令是： `$(CPP) $(CPPFLAGS)` 。

8. 链接Object文件的隐含规则。

   `<n>` 目标依赖于 `<n>.o` ，通过运行C的编译器来运行链接程序生成（一般是 `ld` ），其生成命令是： `$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)` 。这个规则对于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则:

   ```
   x : y.o z.o
   ```

   并且 `x.c` 、 `y.c` 和 `z.c` 都存在时，隐含规则将执行如下命令:

   ```
   cc -c x.c -o x.o
   cc -c y.c -o y.o
   cc -c z.c -o z.o
   cc x.o y.o z.o -o x
   rm -f x.o
   rm -f y.o
   rm -f z.o
   ```

   如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。

9. Yacc C程序时的隐含规则。

   `<n>.c` 的依赖文件被自动推导为 `n.y` （Yacc生成的文件），其生成命令是： `$(YACC)$(YFALGS)` 。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）

10. Lex C程序时的隐含规则。

    `<n>.c` 的依赖文件被自动推导为 `n.l` （Lex生成的文件），其生成命令是： `$(LEX) $(LFALGS)`。（关于“Lex”的细节请查看相关资料）

11. Lex Ratfor程序时的隐含规则。

    `<n>.r` 的依赖文件被自动推导为 `n.l` （Lex生成的文件），其生成命令是： `$(LEX) $(LFALGS)`。

12. 从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。

    `<n>.ln` （lint生成的文件）的依赖文件被自动推导为 `n.c` ，其生成命令是： `$(LINT)$(LINTFALGS) $(CPPFLAGS) -i` 。对于 `<n>.y` 和 `<n>.l` 也是同样的规则。

    ## 隐含规则使用的变量

第一条隐含规则——编译C程序的隐含规则的命令是 `$(CC) –c $(CFLAGS) $(CPPFLAGS)` 。Make默认的编译命令是 `cc` ，如果你把变量 `$(CC)` 重定义成 `gcc` ，把变量 `$(CFLAGS)` 重定义成 `-g`，那么，隐含规则中的命令全部会以 `gcc –c -g $(CPPFLAGS)` 的样子来执行了。

- `AR` : 函数库打包程序。默认命令是 `ar`

- `AS` : 汇编语言编译程序。默认命令是 `as`

- `CC` : C语言编译程序。默认命令是 `cc`

- `CXX` : C++语言编译程序。默认命令是 `g++`

- `CO` : 从 RCS文件中扩展文件程序。默认命令是 `co`

- `CPP` : C程序的预处理器（输出是标准输出设备）。默认命令是 `$(CC) –E`

- `FC` : Fortran 和 Ratfor 的编译器和预处理程序。默认命令是 `f77`

- `GET` : 从SCCS文件中扩展文件的程序。默认命令是 `get`

- `LEX` : Lex方法分析器程序（针对于C或Ratfor）。默认命令是 `lex`

- `PC` : Pascal语言编译程序。默认命令是 `pc`

- `YACC` : Yacc文法分析器（针对于C程序）。默认命令是 `yacc`

- `YACCR` : Yacc文法分析器（针对于Ratfor程序）。默认命令是 `yacc –r`

- `MAKEINFO` : 转换Texinfo源文件（.texi）到Info文件程序。默认命令是 `makeinfo`

- `TEX` : 从TeX源文件创建TeX DVI文件的程序。默认命令是 `tex`

- `TEXI2DVI` : 从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是 `texi2dvi`

- `WEAVE` : 转换Web到TeX的程序。默认命令是 `weave`

- `CWEAVE` : 转换C Web 到 TeX的程序。默认命令是 `cweave`

- `TANGLE` : 转换Web到Pascal语言的程序。默认命令是 `tangle`

- `CTANGLE` : 转换C Web 到 C。默认命令是 `ctangle`

- `RM` : 删除文件命令。默认命令是 `rm –f`

  ### 关于命令参数的变量[¶](https://seisman.github.io/how-to-write-makefile/implicit_rules.html#id6)

  下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是空。

  - `ARFLAGS` : 函数库打包程序AR命令的参数。默认值是 `rv`
  - `ASFLAGS` : 汇编语言编译器参数。（当明显地调用 `.s` 或 `.S` 文件时）
  - `CFLAGS` : C语言编译器参数。
  - `CXXFLAGS` : C++语言编译器参数。
  - `COFLAGS` : RCS命令参数。
  - `CPPFLAGS` : C预处理器参数。（ C 和 Fortran 编译器也会用到）。
  - `FFLAGS` : Fortran语言编译器参数。
  - `GFLAGS` : SCCS “get”程序参数。
  - `LDFLAGS` : 链接器参数。（如： `ld` ）
  - `LFLAGS` : Lex文法分析器参数。
  - `PFLAGS` : Pascal语言编译器参数。
  - `RFLAGS` : Ratfor 程序的Fortran 编译器参数。
  - `YFLAGS` : Yacc文法分析器参数。

  ## 定义模式规则[¶](https://seisman.github.io/how-to-write-makefile/implicit_rules.html#id8)

  你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有 `%` 字符。 `%` 的意思是表示一个或多个任意字符。在依赖目标中同样可以使用 `%` ，只是依赖目标中的 `%` 的取值，取决于其目标。

  有一点需要注意的是， `%` 的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入 Makefile时，而模式规则中的 `%` 则发生在运行时。

  ### 模式规则介绍[¶](https://seisman.github.io/how-to-write-makefile/implicit_rules.html#id9)

  模式规则中，至少在规则的目标定义中要包含 `%` ，否则，就是一般的规则。目标中的 `%` 定义表示对文件名的匹配， `%` 表示长度任意的非空字符串。例如： `%.c` 表示以 `.c` 结尾的文件名（文件名的长度至少为3），而 `s.%.c` 则表示以 `s.` 开头， `.c` 结尾的文件名（文件名的长度至少为5）。

  如果 `%` 定义在目标中，那么，依赖中的 `%` 的值决定了目标中的 `%` 的值，也就是说，依赖中的模式的 `%` 决定了目标中 `%` 的样子。例如有一个模式规则如下：

  ```
  %.o : %.c ; <command ......>;
  ```

  其含义是，指出了怎么从所有的 `.c` 文件生成相应的 `.o` 文件的规则。如果要生成的目标是 `a.ob.o` ，那么 `%c` 就是 `a.c b.c` 。

  一旦依赖目标中的 `%` 模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。

### 自动化变量

目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。

下面是所有的自动化变量及其说明：

- `$@` : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， `$@` 就是匹配于目标中模式定义的集合。
- `$%` : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 `foo.a(bar.o)` ，那么， `$%` 就是 `bar.o` ， `$@` 就是 `foo.a` 。如果目标不是函数库文件（Unix下是 `.a` ，Windows下是 `.lib` ），那么，其值为空。
- `$<` : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 `%` ）定义的，那么 `$<` 将是符合模式的一系列的文件集。注意，其是一个一个取出来的。
- `$?` : 所有比目标新的依赖目标的集合。以空格分隔。
- `$^` : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。
- `$+` : 这个变量很像 `$^` ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。
- `$*` : 这个变量表示目标模式中 `%` 及其之前的部分。如果目标是 `dir/a.foo.b` ，并且目标的模式是 `a.%.b` ，那么， `$*` 的值就是 `dir/foo` 。这个变量对于构造有关联的文件名是比较有效。如果目标中没有模式的定义，那么 `$*` 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 `$*` 就是除了后缀的那一部分。例如：如果目标是 `foo.c` ，因为 `.c` 是make所能识别的后缀名，所以， `$*` 的值就是 `foo` 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 `$*` ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 `$*` 就是空值。

```
$(@D)
```

表示 `$@` 的目录部分（不以斜杠作为结尾），如果 `$@` 值是 `dir/foo.o` ，那么 `$(@D)` 就是 `dir` ，而如果 `$@` 中没有包含斜杠的话，其值就是 `.` （当前目录）。

```
$(@F)
```

表示 `$@` 的文件部分，如果 `$@` 值是 `dir/foo.o` ，那么 `$(@F)` 就是 `foo.o` ， `$(@F)` 相当于函数 `$(notdir $@)` 。

```
$(*D)`, `$(*F)
```

和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， `$(*D)` 返回 `dir` ，而 `$(*F)` 返回 `foo`

```
$(%D)`, `$(%F)
```

分别表示了函数包文件成员的目录部分和文件部分。这对于形同 `archive(member)` 形式的目标中的 `member` 中包含了不同的目录很有用。

```
$(<D)`, `$(<F)
```

分别表示依赖文件的目录部分和文件部分。

```
$(^D)`, `$(^F)
```

分别表示所有依赖文件的目录部分和文件部分。（无相同的）

```
$(+D)`, `$(+F)
```

分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）

```
$(?D)`, `$(?F)
```

分别表示被更新的依赖文件的目录部分和文件部分。

对于 `$<` ，为了避免产生不必要的麻烦，我们最好给 `$` 后面的那个特定字符都加上圆括号，比如， `$(<)` 就要比 `$<` 要好一些。